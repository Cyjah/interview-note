#### 有哪些数据类型
JavaScript中数据类型目前共有8种，其中这8种又分为两类：基本数据类型和引用数据类型(Object)。这两类数据类型的区别是存储的位置不同，基础数据类型存储与栈中，引用数据类型的key(指针)存储在栈中，值存在堆中
基本数据类型是一种既非对象也无方法的数据，[基本类型值可以被替换，但不可以被改变。](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)
```javascript {.line-numbers}
let bar = 'baz'
console.log(bar) // baz
bar.toUpperCase()
console.log(bar) // baz
```
基本数据类型有：string,number,boolean,null,undefined,symbol,bigint。
引用数据类型：Object,也包括Array,Fuction这些对象。

---

### 检测数据类型的方式
1.typeof: 可以检测大部分基本数据类型，但是typeof检测null和Object类型的数据都会得到'object'结果
```javascript {.line-numbers}
console.log(typeof null) // 'object'
let obj = {}
console.log(typeof obj) // 'object'
```

2.instanceof: 原理是通过原型链来检测数据类型，判断在其原型链中能否找到该类型的原型，可以正确判断对象的数据类型。
```javascript {.line-numbers}
console.log(2 instanceof Number) // false
console.log([] instance of Array) // true
console.log(function() {} instanceof Function) // true
console.log({} instanceof Object) // true
```
**intanceof的实现原理及实现**
它本身用于检测构造函数的prototype属性是否出现在某个实例对象的原型链上。
```javascript{.line-numbers}
function self_instanceof(left, right) {
  if (typeof right !== 'function') {
    throw Error() // 右侧必须是一个构造函数
  }
  if (Object.prototype.toString.call(left).slice(8, -1) === 'Null' || typeof (left) !== 'object') {
    // 此判断是为了区分基本数据类型,因为在ES2015中，Object.getPrototypeOf()方法会把基本类型强制包装成对象类型
    return false
  }
  let leftProto = Object.getPrototypeOf(left)
  let rightProto = right.prototype
  while (true) {
    if (!leftProto) {
      return false
    }
    if (leftProto === rightProto) {
      return true
    }
    leftProto = Object.getPrototypeOf(leftProto)
  }
}
```

3.constructor
* 判断数据类型
```javascript{.line-numbers}
console.log((2).constructor === Number) // true
```
* 对象实例通过constructor对象访问它的构造函数。==注意:== 如果创建了一个对象来改变它的原型，constructor就不能用来判断数据类型。
```javascript{.line-numbers}
function F() {}
F.prototype = new Array()
var f = new F()
console.log(f.constructor === F) // false
console.log(f.constructor = Array) // true
```

4.Object.prototype.toString.call()
```javascript{.line-numbers}
console.log(Object.prototype.toString.call(2)) // [object Number]
```
注意：Object.toString()和Object.prototype.toString.call()的结果是不同的，toString是Object原型方法，但是Object也重写了toString方法，所以根据原型链知识，Object.toString()调用的是重写后的方法.

### 判断数组的方式
```javascript
1.Array.isArray()
```

```javascript
2.Object.prototye.toString.call(obj).slice(8, -1) === 'Array'
```

```javascript
3.obj.__proto__ = Array.prototype
```

```javascript
4.Array.isPrototypeOf(obj)
```

```javascript
5.obj instanceof Array
```

##### null 和 undefined的区别?
undefined表示未定义，一般变量声明了但未定义就会返回undefined;null表示为空，null主要赋值给一些可能会返回对象的变量做初始化。
typeof undefined的结果是undefined, typeof null的结果是object。
```javascript{.line-numbers}
let test
console.log(typeof test) // undefined
let test1 = null
console.log(typeof test1) // object
```
**为什么typeof null的结果是object?**
在JavaScript的第一个版本的时候，所有值都存储在32位的单元中,每个单元的32位里的1-3位表示TYPE TAG.类型标签存储在每个单元的低位中，共有五种数据类型：
```
000: object 对象
1: int  31位的有符号整数
010: double  双精度浮点数
100: string  字符串
010: boolean  布尔值
```
特殊数据类型：
1.undefined的值是-2(30)
2.null的值是机器码NULL，指针全是0，即null的TYPE TAG也是000.

面试可回答：在JavaScript的第一个版本中，所有的值都存储在32位单元中，每个单元里的32位的1-3位表示类型标签，object对象的类型标签是000，而null的值是机器码NULL,指针全为0，所以null的类型标签也是000,在typeof判断类型的时候就会被误判。

**为什么0.1+0.2不等于0.3，怎么处理让他们相等呢？**
因为计算机是通过二进制存储数据的，所以0.1+0.2的时候时间是计算0.1和0.2的二进制之和，而0.1的二进制是0.00011001100...(1100循环)，0.2的二进制是0.0011001100...(1100循环),ES6之前JavaScript中只有一种数据类型Number，遵循IEEE 754标准，用64位固定长度表示，在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，剩余的需舍去，遵循"0舍1入"原则。根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：0.30000000000000004。
让0.1+0.2=0.3的解决方法：ES6中有Number.EPSILON，值为2的-52，只要判断0.1+0.2-0.3 < Number.EPSILON为true,则0.1+0.2=0.3
```javascript{.line-number}
const numberEpsilon = (num1, num2) => {
  return Math.abs(num1 - num2) < Number.EPSILON
}
console.log(numberEpsilon(0.1+0.2, 0.3)) // true
```

**如何获取安全的undefined值**
首先可以通过void来获取undefined值，无论void后面接什么，都会返回undefined,一般使用void 0。要用void 0来获取undefined的原因是因为undefined不是一个保留字，它可以在非全局作用域中被当作标识符来使用。如下：
```javascript
function test(a, b) {
  let undefined = 10
  if (a === undefined || b === undefined) {
    console.log("参数错误")
  } else {
    console.log(a + b)
  }
}
test(10, 10) // 参数错误
```
为防止上面代码的情况，可以改成：
```javascript
function test(a, b) {
  let undefined = 10
  if (a === void 0 || b === void 0) {
    console.log("参数错误")
  } else {
    console.log(a + b)
  }
}
test(10, 10) // 20
```
**NaN:一个特殊值，它和自身不相等**
```javascript
console.log(typeof NaN) // number
```
有2个方法判断是否是NaN,一个是isNaN()，一个是ES6中的Number.isNaN(),两者的区别是isNaN会自行把参数转换成数字，而Number.isNaN()则不会，只有参数的值是NaN的数字时，才返回true。
```javascript
console.log(isNaN("123abc")) // false
console.log(Number.isNaN("123abc")) // true
```